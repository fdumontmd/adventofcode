const INPUT: &str = include_str!("input.txt");

fn parse_part1(input: &str) -> Vec<Option<usize>> {
    let input = input.trim();
    let mut ids = vec![];

    let mut file = true;
    let mut id = 0;

    for c in input.chars() {
        if c.is_ascii_digit() {
            let d = c as usize - '0' as usize;
            if file {
                for _ in 0..d {
                    ids.push(Some(id));
                }
                id += 1;
            } else {
                for _ in 0..d {
                    ids.push(None);
                }
            }
            file = !file;
        } else {
            panic!("unknown character '{c}'");
        }
    }

    ids
}

fn part1(input: &str) -> usize {
    let mut ids = parse_part1(input);

    let mut free_pos: Vec<usize> = ids
        .iter()
        .enumerate()
        .filter_map(|(pos, id)| if id.is_none() { Some(pos) } else { None })
        .collect();

    free_pos.reverse();

    // we'll pop from the end and swap with the first false location
    while let Some(pos) = free_pos.pop() {
        if pos >= ids.len() {
            break;
        }

        loop {
            if let Some(Some(id)) = ids.pop() {
                ids[pos] = Some(id);
                break;
            }
        }
    }

    ids.into_iter()
        .enumerate()
        .map(|(pos, id)| pos * id.unwrap_or(0))
        .sum()
}

struct File {
    pos: usize,
    len: usize,
    id: usize,
}

struct FreeBlock {
    pos: usize,
    len: usize,
}

// yes, Clippy. Those are very complex types... I should really introduce something more readable
fn parse_part2(input: &str) -> (Vec<File>, Vec<FreeBlock>) {
    let mut files = vec![];
    let mut free_blocks = vec![];

    let mut file = true;
    let mut id = 0;
    let mut pos = 0;

    for c in input.chars() {
        if c.is_ascii_digit() {
            let len = c as usize - '0' as usize;

            if file {
                files.push(File { pos, len, id });
                id += 1;
            } else {
                free_blocks.push(FreeBlock { pos, len });
            }
            pos += len;
            file = !file;
        }
    }

    (files, free_blocks)
}

// we do not need to consider the free space generated by moving files, as they are always to the
// right of all subsequent files, and we can only move left
fn part2(input: &str) -> usize {
    let (files, mut free_blocks) = parse_part2(input);

    files
        .into_iter()
        .rev()
        .map(|File { pos, len, id }| {
            // we're trying to find a free block large enough and to the left of the file
            if let Some(idx) = free_blocks
                .iter()
                .position(|fb| fb.len >= len && fb.pos < pos)
            {
                // if found, we relocate the file to that free block, adjusting the free block
                // position and free space
                let new_block = File {
                    pos: free_blocks[idx].pos,
                    len,
                    id,
                };
                free_blocks[idx].pos += len;
                free_blocks[idx].len -= len;
                if free_blocks[idx].len == 0 {
                    free_blocks.remove(idx);
                }
                new_block
            } else {
                // otherwise, leave the file where it is
                File { pos, len, id }
            }
        })
        .flat_map(|File { pos, len, id }| (pos..(pos + len)).map(move |p| p * id))
        .sum()
}

fn main() {
    println!("part 1: {}", part1(INPUT));
    println!("part 2: {}", part2(INPUT));
}

#[cfg(test)]
mod tests {
    use super::*;
    use test_case::test_case;

    const TEST_INPUT: &str = "2333133121414131402";

    #[test_case(TEST_INPUT, 1928; "test input")]
    #[test_case(INPUT, 6307275788409; "input")]
    fn test_part1(input: &str, checksum: usize) {
        assert_eq!(checksum, part1(input));
    }

    #[test_case(TEST_INPUT, 2858; "test input")]
    #[test_case(INPUT, 6327174563252; "input")]
    fn test_part2(input: &str, checksum: usize) {
        assert_eq!(checksum, part2(input));
    }
}
